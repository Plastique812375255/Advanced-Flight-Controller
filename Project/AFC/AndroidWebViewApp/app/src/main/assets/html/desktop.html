<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态桌面</title>
    <style>
        /* 基本样式 */
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        /* 容器样式 */
        #desktop {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
        }
        
        /* 网格样式 */
        .desktop-grid {
            position: relative;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            height: 95vh;
            width: calc(95vh * 2);
            aspect-ratio: 2/1;
        }
        
        /* 编辑模式下的网格 */
        .desktop-grid.edit-mode {
            background-color: #eaeaea;
            border: 2px dashed #aaa;
        }
        
        .edit-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        #exitEditModeBtn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
        }
        
        /* 组件样式 */
        .widget {
            position: absolute;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .widget.selected {
            box-shadow: 0 0 0 2px #2196F3, 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .widget-header {
            padding: 8px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .widget-title {
            font-weight: bold;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .widget-content {
            padding: 10px;
            height: calc(100% - 40px);
            overflow: auto;
        }
        
        /* 遮罩层 */
        #widgetMenuOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: none;
        }
        
        #widgetMenuOverlay.active {
            display: block;
        }
        
        /* 组件选择侧边菜单 */
        #widgetMenu {
            position: fixed;
            top: 0;
            right: -300px;
            width: 280px;
            height: 100vh;
            background-color: white;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 10001;
            overflow-y: auto;
            transition: right 0.3s ease;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }
        
        #widgetMenu.active {
            right: 0;
            display: block !important;
        }
        
        .widget-menu-title {
            font-weight: bold;
            padding: 15px;
            background-color: #f5f5f5;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .widget-menu-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #888;
        }
        
        #widgetList {
            padding: 10px;
        }
        
        .widget-option {
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            border-radius: 6px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .widget-option:hover {
            background-color: #f0f0f0;
            border-color: #ddd;
        }
        
        .widget-option-icon {
            background-color: #e0e0e0;
            color: #666;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .system-widget .widget-option-icon {
            background-color: #bbdefb;
            color: #1976d2;
        }
        
        .user-widget .widget-option-icon {
            background-color: #c8e6c9;
            color: #388e3c;
        }
        
        /* 删除区域样式 */
        #deleteZone {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: 60px;
            background: linear-gradient(to bottom, rgba(255, 0, 0, 0.8), rgba(255, 0, 0, 0.5));
            z-index: 10002;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            text-align: center;
            animation: pulse 2s infinite;
            transition: all 0.3s ease;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        #deleteZone.drag-over {
            background: linear-gradient(to bottom, rgb(255, 0, 0), rgba(255, 0, 0, 0.7));
            height: 80px;
        }
        
        .trash-icon {
            font-size: 24px;
            margin-right: 10px;
        }
        
        .delete-text {
            color: white;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        /* AFC菜单样式 */
        #afcMenuOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: none;
        }
        
        #afcMenu {
            position: fixed;
            top: 0;
            right: -300px;
            width: 280px;
            height: 100vh;
            background-color: white;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            z-index: 10001;
            overflow-y: auto;
            transition: right 0.3s ease;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }
        
        #afcMenuList {
            padding: 10px;
        }
        
        .menu-option {
            padding: 15px;
            margin-bottom: 8px;
            cursor: pointer;
            border-radius: 6px;
            background-color: #f9f9f9;
            border: 1px solid #eee;
            transition: all 0.2s;
            display: flex;
            align-items: center;
        }
        
        .menu-option:hover,
        .menu-option:active {
            background-color: #e8e8e8;
            border-color: #ddd;
        }
        
        .menu-icon {
            width: 24px;
            height: 24px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #e0e0e0;
            border-radius: 50%;
            color: #555;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* 功能按钮样式 */
        .widget-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px;
            margin-left: 5px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        
        .widget-button:hover {
            opacity: 1;
        }
        
        /* 尺寸调整句柄 */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #2196F3;
            border-radius: 50%;
            bottom: 2px;
            right: 2px;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .selected .resize-handle {
            opacity: 1;
        }
        
        .instructions {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 80%;
        }
        
        /* 提示样式 */
        .instructions h3 {
            margin-top: 0;
        }
        
        .instructions p {
            margin-bottom: 5px;
        }
    </style>
    <!-- 引入基类和组件管理器 -->
    <script>
    /**
     * 组件基类 - 所有组件都应该继承这个类
     */
    class BaseWidget {
        constructor(config) {
            this.config = config || {};
            this.element = null;
        }
        
        /**
         * 获取组件ID
         */
        getId() {
            return this.constructor.getMetadata().id;
        }
        
        /**
         * 创建组件DOM元素
         */
        createDOMElement() {
            this.element = document.createElement('div');
            this.element.className = 'widget';
            this.element.dataset.widgetId = this.getId();
            this.element.dataset.col = this.config.col;
            this.element.dataset.row = this.config.row;
            this.element.dataset.width = this.config.width;
            this.element.dataset.height = this.config.height;
            
            // 添加组件内容
            this.renderContent();
            
            return this.element;
        }
        
        /**
         * 渲染组件内容 (子类应该重写这个方法)
         */
        renderContent() {
            this.element.innerHTML = `<div class="widget-content">${this.constructor.getMetadata().name}</div>`;
        }
        
        /**
         * 更新组件配置
         */
        updateConfig(newConfig) {
            this.config = { ...this.config, ...newConfig };
            
            // 更新元素属性
            if (this.element) {
                this.element.dataset.col = this.config.col;
                this.element.dataset.row = this.config.row;
                this.element.dataset.width = this.config.width;
                this.element.dataset.height = this.config.height;
            }
        }
        
        /**
         * 获取组件元数据 (静态方法，子类必须重写)
         */
        static getMetadata() {
            return {
                id: 'base.widget',
                name: '基础组件',
                description: '组件基类，不应直接使用',
                width: 1,
                height: 1
            };
        }
    }

    // 设置为全局对象
    window.BaseWidget = BaseWidget;
    </script>
    <!-- 引入组件管理器 -->
    <script src="js/widget-manager.js"></script>
    
    <!-- 移除手动加载组件的代码，避免undefined错误 -->
</head>
<body>
    <!-- 删除组件区域 -->
    <div id="deleteZone">
        <div class="trash-icon">🗑️</div>
        <div class="delete-text">拖动到此处删除组件</div>
    </div>
    
    <div id="desktop">
        <!-- 网格容器 -->
        <div id="desktopGrid" class="desktop-grid">
            <!-- 组件将在这里显示 -->
        </div>
        
        <!-- 如果没有组件，显示指引 -->
        <div class="instructions">
            <h3>欢迎使用动态桌面</h3>
            <p>长按桌面进入编辑模式</p>
            <p>在编辑模式下可以移动、删除和添加组件</p>
            <p>在编辑模式下点击空白处可以添加新组件</p>
            <p>完成后点击左上角的退出按钮</p>
        </div>
        
        <!-- 编辑模式控制区 -->
        <div class="edit-controls" style="display: none;">
            <button id="exitEditModeBtn" style="background-color: #f44336; color: white; border: none; padding: 8px 12px; border-radius: 4px; font-weight: bold; cursor: pointer;">退出编辑</button>
        </div>
    </div>
    
    <!-- 遮罩层 -->
    <div id="widgetMenuOverlay"></div>
    
    <!-- 组件选择菜单 -->
    <div id="widgetMenu">
        <div class="widget-menu-title">
            添加组件
            <button class="widget-menu-close" onclick="hideWidgetMenu()">×</button>
        </div>
        <div id="widgetList"></div>
    </div>
    
    <!-- AFC侧边菜单遮罩层 -->
    <div id="afcMenuOverlay" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); z-index: 10000; display: none;"></div>
    
    <!-- AFC侧边菜单 -->
    <div id="afcMenu" style="position: fixed; top: 0; right: -300px; width: 280px; height: 100vh; background-color: white; box-shadow: 0 0 15px rgba(0, 0, 0, 0.2); z-index: 10001; overflow-y: auto; transition: right 0.3s ease;">
        <div class="widget-menu-title">
            AFC
            <button class="widget-menu-close" onclick="hideAfcMenu()">×</button>
        </div>
        <div id="afcMenuList">
            <div class="menu-option"><div class="menu-icon">📡</div>对频</div>
            <div class="menu-option"><div class="menu-icon">🌐</div>语言</div>
            <div class="menu-option"><div class="menu-icon">⚙️</div>系统设置</div>
            <div class="menu-option"><div class="menu-icon">👤</div>账号与同步</div>
            <div class="menu-option"><div class="menu-icon">🛒</div>应用商店</div>
            <div class="menu-option"><div class="menu-icon">🎨</div>主题设置</div>
            <div class="menu-option"><div class="menu-icon">ℹ️</div>关于我们</div>
            <div class="menu-option"><div class="menu-icon">❓</div>帮助中心</div>
            <div class="menu-option"><div class="menu-icon">🔄</div>版本更新</div>
            <div class="menu-option"><div class="menu-icon">🔔</div>通知设置</div>
            <div class="menu-option"><div class="menu-icon">🔒</div>隐私设置</div>
            <div class="menu-option"><div class="menu-icon">💾</div>数据备份</div>
            <div class="menu-option"><div class="menu-icon">📶</div>网络设置</div>
            <div class="menu-option"><div class="menu-icon">💽</div>存储管理</div>
            <div class="menu-option"><div class="menu-icon">🔧</div>开发者选项</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            // 移除说明文本
            const instructions = document.querySelector('.instructions');
            if (instructions) {
                instructions.style.display = 'none';
            }
            
            const desktopGrid = document.getElementById('desktopGrid');
            let editMode = false;
            let longPressTimer;
            let draggedWidget = null;
            let initialX, initialY;
            let initialLeft, initialTop;
            let isDragging = false; // 跟踪是否正在拖拽
            
            // 强制隐藏删除区域
            const deleteZone = document.getElementById('deleteZone');
            if (deleteZone) {
                deleteZone.style.display = 'none';
                deleteZone.classList.remove('drag-over');
            }
            
            // 创建组件管理器
            const widgetManager = new WidgetManager(desktopGrid);
            
            // 调整桌面尺寸
            function resizeDesktop() {
                console.log('调整桌面尺寸');
                
                // 简化布局计算，aspect-ratio CSS属性会自动保持12:6的宽高比
                // 所以不需要手动计算和设置尺寸
                
                // 获取实际尺寸
                const gridWidth = desktopGrid.clientWidth;
                const gridHeight = desktopGrid.clientHeight;
                console.log(`网格实际尺寸: ${gridWidth}x${gridHeight}`);
                
                // 计算格子大小并更新组件管理器
                const cellWidth = gridWidth / 12;
                const cellHeight = gridHeight / 6;
                console.log(`单元格尺寸: ${cellWidth}x${cellHeight}`);
                
                widgetManager.setCellSize(cellWidth, cellHeight);
            }
            
            // 初始化组件管理器和调整大小
            try {
                // 移除加载指示器
                function removeLoading() {
                    const loading = desktopGrid.querySelector('.loading');
                    if (loading) {
                        loading.remove();
                    }
                }
                
                // 初始化组件管理器
                await widgetManager.init();
                removeLoading();
                
                // 调整大小
                resizeDesktop();
                
                // 监听窗口大小变化
                window.addEventListener('resize', resizeDesktop);
                
                // 初始化拖拽功能
                initDragFunctionality();
                
                // 初始化滑动手势识别
                initSwipeGesture();
                
            } catch (error) {
                console.error('初始化失败:', error);
                desktopGrid.innerHTML = `
                    <div class="loading">
                        <div style="color: red">加载失败</div>
                        <div>${error.message}</div>
                    </div>
                `;
            }
            
            function initDragFunctionality() {
                console.log('初始化长按进入编辑模式功能');
                
                // 长按进入编辑模式
                desktopGrid.addEventListener('mousedown', function(e) {
                    console.log('鼠标按下事件触发');
                    // 只有在非编辑模式下才启动长按计时器
                    if (!editMode) {
                        longPressTimer = setTimeout(function() {
                            console.log('长按计时器执行，进入编辑模式');
                            enterEditMode();
                        }, 500); // 500ms长按时间
                    }
                });
                
                desktopGrid.addEventListener('touchstart', function(e) {
                    console.log('触摸开始事件触发');
                    // 只有在非编辑模式下才启动长按计时器
                    if (!editMode) {
                        longPressTimer = setTimeout(function() {
                            console.log('长按计时器执行，进入编辑模式');
                            enterEditMode();
                        }, 500); // 500ms长按时间
                    }
                });
                
                // 取消长按
                desktopGrid.addEventListener('mouseup', function() {
                    clearTimeout(longPressTimer);
                });
                
                desktopGrid.addEventListener('touchend', function() {
                    clearTimeout(longPressTimer);
                });
                
                desktopGrid.addEventListener('mouseleave', function() {
                    clearTimeout(longPressTimer);
                });
                
                // 左上角退出按钮
                const exitEditBtn = document.getElementById('exitEditModeBtn');
                if (exitEditBtn) {
                    exitEditBtn.addEventListener('click', function(e) {
                        exitEditMode();
                        e.stopPropagation(); // 防止触发其他点击事件
                    });
                }
                
                // 点击空白区域添加组件
                desktopGrid.addEventListener('click', function(e) {
                    // 只在编辑模式下且点击的不是组件和控制按钮时显示组件菜单
                    if (editMode && 
                        !e.target.closest('.widget') && 
                        !e.target.closest('.edit-controls') && 
                        !e.target.closest('#widgetMenu')) {
                        
                        showWidgetMenu(e.clientX, e.clientY);
                    }
                });
                
                // 触摸版本
                desktopGrid.addEventListener('touchend', function(e) {
                    // 确保这是一个轻触而不是拖动结束
                    if (editMode && 
                        !isDragging && 
                        !e.target.closest('.widget') && 
                        !e.target.closest('.edit-controls') && 
                        !e.target.closest('#widgetMenu')) {
                        
                        const touch = e.changedTouches[0];
                        showWidgetMenu(touch.clientX, touch.clientY);
                    }
                });
                
                // 添加组件拖拽事件 - 使用HTML5拖放API
                desktopGrid.addEventListener('mousedown', function(e) {
                    // 在拖拽开始时不做任何事情，拖拽功能由draggable属性和dragstart事件处理
                    // 所有组件在编辑模式中会自动获得draggable=true属性
                });
                
                desktopGrid.addEventListener('touchstart', function(e) {
                    // 也不做任何事情，拖拽功能由draggable属性和dragstart事件处理
                });
            }
            
            // 进入编辑模式
            function enterEditMode() {
                console.log('进入编辑模式');
                
                // 设置编辑模式标志
                editMode = true;
                
                // 显示控制按钮
                const exitEditBtn = document.getElementById('exitEditModeBtn');
                if (exitEditBtn) {
                    exitEditBtn.style.display = 'block';
                }
                
                // 显示删除区域
                const deleteZone = document.getElementById('deleteZone');
                if (deleteZone) {
                    deleteZone.style.display = 'flex';
                }
                
                // 添加编辑模式样式
                desktopGrid.classList.add('edit-mode');
                
                // 为每个组件添加可拖动属性
                const widgets = document.querySelectorAll('.widget');
                widgets.forEach(widget => {
                    widget.setAttribute('draggable', 'true');
                    widget.classList.add('widget-edit-mode');
                    
                    // 添加拖拽事件监听器 - PC
                    widget.addEventListener('dragstart', handleDragStart);
                    widget.addEventListener('dragend', handleDragEnd);
                    
                    // 添加触摸拖拽监听器 - 移动设备
                    widget.addEventListener('touchstart', handleDragStart);
                });
                
                // 添加文档级别的触摸移动和结束监听
                document.addEventListener('touchmove', handleTouchMove);
                document.addEventListener('touchend', handleTouchEnd);
                
                // 为网格添加拖放区域事件
                desktopGrid.addEventListener('dragover', handleDragOver);
                desktopGrid.addEventListener('drop', handleDrop);
                
                // 为删除区域添加拖放事件
                if (deleteZone) {
                    deleteZone.addEventListener('dragover', handleDeleteZoneOver);
                    deleteZone.addEventListener('dragleave', handleDeleteZoneLeave);
                    deleteZone.addEventListener('drop', handleDeleteZoneDrop);
                }
                
                // 保存当前布局以便在取消时恢复
                saveCurrentLayout();
            }
            
            // 退出编辑模式
            function exitEditMode() {
                console.log('退出编辑模式');
                
                // 关闭编辑模式标志
                editMode = false;
                
                // 隐藏控制按钮
                const exitEditBtn = document.getElementById('exitEditModeBtn');
                if (exitEditBtn) {
                    exitEditBtn.style.display = 'none';
                }
                
                // 隐藏删除区域
                const deleteZone = document.getElementById('deleteZone');
                if (deleteZone) {
                    deleteZone.style.display = 'none';
                    deleteZone.classList.remove('drag-over');
                }
                
                // 移除编辑模式样式
                desktopGrid.classList.remove('edit-mode');
                
                // 移除组件的可拖动属性
                const widgets = document.querySelectorAll('.widget');
                widgets.forEach(widget => {
                    widget.removeAttribute('draggable');
                    widget.classList.remove('widget-edit-mode');
                    
                    // 移除PC拖拽事件监听器
                    widget.removeEventListener('dragstart', handleDragStart);
                    widget.removeEventListener('dragend', handleDragEnd);
                    
                    // 移除触摸拖拽监听器
                    widget.removeEventListener('touchstart', handleDragStart);
                });
                
                // 移除文档级别的触摸移动和结束监听
                document.removeEventListener('touchmove', handleTouchMove);
                document.removeEventListener('touchend', handleTouchEnd);
                
                // 移除网格的拖放区域事件
                desktopGrid.removeEventListener('dragover', handleDragOver);
                desktopGrid.removeEventListener('drop', handleDrop);
                
                // 移除删除区域的拖放事件
                if (deleteZone) {
                    deleteZone.removeEventListener('dragover', handleDeleteZoneOver);
                    deleteZone.removeEventListener('dragleave', handleDeleteZoneLeave);
                    deleteZone.removeEventListener('drop', handleDeleteZoneDrop);
                }
                
                // 保存最终布局
                widgetManager.saveLayout();
            }
            
            // 删除区域的拖拽事件处理
            function handleDeleteZoneOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                this.classList.add('drag-over');
            }
            
            function handleDeleteZoneLeave(e) {
                this.classList.remove('drag-over');
            }
            
            function handleDeleteZoneDrop(e) {
                e.preventDefault();
                const widgetId = e.dataTransfer.getData('text/plain');
                const widget = document.getElementById(widgetId);
                
                if (widget) {
                    console.log(`删除组件: ${widgetId}`);
                    
                    // 从DOM中移除组件
                    widget.remove();
                    
                    // 从管理器中移除组件
                    widgetManager.removeWidget(widgetId);
                    
                    // 保存布局
                    widgetManager.saveLayout();
                }
                
                // 移除拖拽样式
                this.classList.remove('drag-over');
            }
            
            // 组件拖拽变量
            let currentDragWidget = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            
            // 组件拖拽开始 - 支持PC和移动设备
            function handleDragStart(e) {
                // PC设备拖拽支持
                if (e.dataTransfer) {
                    e.dataTransfer.setData('text/plain', this.id);
                    e.dataTransfer.effectAllowed = 'move';
                }
                
                this.classList.add('dragging');
                
                // 记录初始位置
                const rect = this.getBoundingClientRect();
                
                // 根据事件类型获取客户端坐标
                let clientX, clientY;
                if (e.type === 'touchstart') {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const offsetX = clientX - rect.left;
                const offsetY = clientY - rect.top;
                
                // 保存拖拽偏移量
                this.dataset.dragOffsetX = offsetX;
                this.dataset.dragOffsetY = offsetY;
                
                // 设置当前拖拽组件和状态（用于触摸设备）
                currentDragWidget = this;
                isDragging = true;
                dragOffsetX = offsetX;
                dragOffsetY = offsetY;
                
                console.log(`开始拖拽组件: ${this.id}, 偏移量: X=${offsetX}, Y=${offsetY}`);
                
                // 阻止触摸设备上的滚动
                if (e.type === 'touchstart') {
                    e.preventDefault();
                }
            }
            
            // 组件拖拽结束
            function handleDragEnd(e) {
                this.classList.remove('dragging');
                
                // 清除拖拽数据
                delete this.dataset.dragOffsetX;
                delete this.dataset.dragOffsetY;
                
                console.log(`结束拖拽组件: ${this.id}`);
            }
            
            // 拖拽经过桌面网格
            function handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const deleteZone = document.getElementById('deleteZone');
                if (deleteZone) {
                    deleteZone.classList.remove('drag-over');
                }
            }
            
            // 在桌面网格上放置组件
            function handleDrop(e) {
                e.preventDefault();
                
                const widgetId = e.dataTransfer.getData('text/plain');
                const widget = document.getElementById(widgetId);
                
                if (widget) {
                    // 计算相对于桌面的位置
                    const gridRect = desktopGrid.getBoundingClientRect();
                    const relX = e.clientX - gridRect.left;
                    const relY = e.clientY - gridRect.top;
                    
                    // 考虑拖拽偏移量
                    const offsetX = parseFloat(widget.dataset.dragOffsetX || 0);
                    const offsetY = parseFloat(widget.dataset.dragOffsetY || 0);
                    
                    // 计算单元格尺寸
                    const cellWidth = desktopGrid.clientWidth / 12;
                    const cellHeight = desktopGrid.clientHeight / 6;
                    
                    // 计算调整后的位置
                    const adjX = relX - offsetX;
                    const adjY = relY - offsetY;
                    
                    // 计算网格位置
                    const col = Math.floor(adjX / cellWidth);
                    const row = Math.floor(adjY / cellHeight);
                    
                    // 获取组件尺寸
                    const width = parseInt(widget.dataset.width);
                    const height = parseInt(widget.dataset.height);
                    
                    // 确保不超出边界
                    const finalCol = Math.max(0, Math.min(col, 12 - width));
                    const finalRow = Math.max(0, Math.min(row, 6 - height));
                    
                    console.log(`放置组件: ${widgetId} 在位置 列=${finalCol}, 行=${finalRow}`);
                    
                    // 更新位置
                    widget.style.left = `${finalCol * cellWidth}px`;
                    widget.style.top = `${finalRow * cellHeight}px`;
                    
                    // 更新数据属性
                    widget.dataset.col = finalCol;
                    widget.dataset.row = finalRow;
                    
                    // 更新组件配置
                    const widgetObj = widgetManager.widgets.find(w => w.getId() === widgetId);
                    if (widgetObj && widgetObj.config) {
                        widgetObj.config.col = finalCol;
                        widgetObj.config.row = finalRow;
                    }
                    
                    // 触发保存
                    widgetManager.saveLayout();
                }
            }
            
            // 保存当前布局以便在取消时恢复
            function saveCurrentLayout() {
                // 可以实现布局的临时保存和恢复
                console.log('保存当前布局');
            }
            
            // 显示组件选择菜单
            function showWidgetMenu(x, y) {
                // 使用顶层窗口的菜单元素，而不是当前iframe内的
                const topWindow = window.top || window;
                let menu, overlay, widgetList;
                
                // 检查顶层窗口是否存在菜单元素
                if (topWindow.document.getElementById('widgetMenu')) {
                    menu = topWindow.document.getElementById('widgetMenu');
                    overlay = topWindow.document.getElementById('widgetMenuOverlay');
                    widgetList = topWindow.document.getElementById('widgetList');
                } else {
                    // 如果顶层没有，则创建
                    overlay = topWindow.document.createElement('div');
                    overlay.id = 'widgetMenuOverlay';
                    overlay.style.position = 'fixed';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.width = '100vw';
                    overlay.style.height = '100vh';
                    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                    overlay.style.zIndex = '99999';
                    
                    menu = topWindow.document.createElement('div');
                    menu.id = 'widgetMenu';
                    menu.style.position = 'fixed';
                    menu.style.top = '0';
                    menu.style.right = '0';
                    menu.style.width = '280px';
                    menu.style.height = '100vh';
                    menu.style.backgroundColor = 'white';
                    menu.style.boxShadow = '0 0 15px rgba(0, 0, 0, 0.2)';
                    menu.style.zIndex = '100000';
                    menu.style.overflowY = 'auto';
                    
                    const titleDiv = topWindow.document.createElement('div');
                    titleDiv.style.fontWeight = 'bold';
                    titleDiv.style.padding = '15px';
                    titleDiv.style.backgroundColor = '#f5f5f5';
                    titleDiv.style.borderBottom = '1px solid #e0e0e0';
                    titleDiv.style.display = 'flex';
                    titleDiv.style.justifyContent = 'space-between';
                    titleDiv.style.alignItems = 'center';
                    titleDiv.innerHTML = '添加组件';
                    
                    const closeBtn = topWindow.document.createElement('button');
                    closeBtn.style.background = 'none';
                    closeBtn.style.border = 'none';
                    closeBtn.style.fontSize = '18px';
                    closeBtn.style.cursor = 'pointer';
                    closeBtn.style.color = '#888';
                    closeBtn.innerHTML = '×';
                    closeBtn.onclick = hideWidgetMenu;
                    
                    titleDiv.appendChild(closeBtn);
                    menu.appendChild(titleDiv);
                    
                    widgetList = topWindow.document.createElement('div');
                    widgetList.id = 'widgetList';
                    widgetList.style.padding = '10px';
                    menu.appendChild(widgetList);
                    
                    topWindow.document.body.appendChild(overlay);
                    topWindow.document.body.appendChild(menu);
                }
                
                // 清空现有选项
                if (widgetList) {
                    widgetList.innerHTML = '';
                    
                    // 显示硬编码的组件选项
                    widgetList.innerHTML = `
                        <div class="widget-option system-widget" data-widget-id="system.small">
                            <div class="widget-option-icon">1x1</div>
                            <div>小组件</div>
                        </div>
                        <div class="widget-option system-widget" data-widget-id="system.medium">
                            <div class="widget-option-icon">3x1</div>
                            <div>中组件</div>
                        </div>
                        <div class="widget-option system-widget" data-widget-id="system.large">
                            <div class="widget-option-icon">4x2</div>
                            <div>大组件</div>
                        </div>
                        <div class="widget-option user-widget" data-widget-id="user.custom">
                            <div class="widget-option-icon">2x2</div>
                            <div>自定义组件</div>
                        </div>
                        <div class="widget-option system-widget" data-widget-id="system.model-name">
                            <div class="widget-option-icon">3x1</div>
                            <div>模型名称</div>
                        </div>
                        <div class="widget-option system-widget" data-widget-id="system.model-image">
                            <div class="widget-option-icon">4x3</div>
                            <div>模型图片</div>
                        </div>
                    `;
                    
                    // 添加点击事件
                    const options = widgetList.querySelectorAll('.widget-option');
                    options.forEach(option => {
                        option.addEventListener('click', function() {
                            const widgetId = this.dataset.widgetId;
                            addWidgetAtPosition(widgetId, x, y);
                            hideWidgetMenu();
                        });
                    });
                }
                
                // 显示菜单
                if (overlay && menu) {
                    overlay.style.display = 'block';
                    menu.style.right = '0';
                    
                    // 添加遮罩点击事件
                    overlay.onclick = hideWidgetMenu;
                }
            }
            
            // 在指定位置添加组件
            function addWidgetAtPosition(widgetId, clientX, clientY) {
                console.log(`添加组件: ${widgetId} 在位置 X:${clientX}, Y:${clientY}`);
                
                // 计算相对于桌面的位置
                const gridRect = desktopGrid.getBoundingClientRect();
                const relX = clientX - gridRect.left;
                const relY = clientY - gridRect.top;
                console.log(`相对位置: X:${relX}, Y:${relY}`);
                
                // 计算单元格尺寸
                const cellWidth = desktopGrid.clientWidth / 12;
                const cellHeight = desktopGrid.clientHeight / 6;
                console.log(`单元格尺寸: 宽度:${cellWidth}, 高度:${cellHeight}`);
                
                // 计算单元格位置（从0开始）
                const col = Math.floor(relX / cellWidth);
                const row = Math.floor(relY / cellHeight);
                console.log(`网格位置: 列:${col}, 行:${row}`);
                
                // 获取组件默认尺寸
                let width = 1;
                let height = 1;
                
                // 使用硬编码的尺寸
                if (widgetId === 'system.small') {
                    width = 1; height = 1;
                } else if (widgetId === 'system.medium') {
                    width = 3; height = 1;
                } else if (widgetId === 'system.large') {
                    width = 4; height = 2;
                } else if (widgetId === 'user.custom') {
                    width = 2; height = 2;
                } else if (widgetId === 'system.model-name') {
                    width = 3; height = 1;
                } else if (widgetId === 'system.model-image') {
                    width = 4; height = 3;
                }
                console.log(`使用硬编码尺寸: ${width}x${height}`);
                
                // 确保组件不会超出网格边界
                const finalCol = Math.max(0, Math.min(col, 12 - width));
                const finalRow = Math.max(0, Math.min(row, 6 - height));
                console.log(`最终位置: 列:${finalCol}, 行:${finalRow}`);
                
                // 创建组件配置
                const config = {
                    widgetId: widgetId,
                    col: finalCol,
                    row: finalRow,
                    width: width,
                    height: height
                };
                
                // 创建DIV元素
                const element = document.createElement('div');
                element.className = 'widget';
                element.id = 'widget_' + Date.now(); // 生成唯一ID
                element.dataset.widgetId = widgetId;
                element.dataset.col = finalCol;
                element.dataset.row = finalRow;
                element.dataset.width = width;
                element.dataset.height = height;
                
                // 设置位置和尺寸
                element.style.width = `${cellWidth * width - 5}px`;
                element.style.height = `${cellHeight * height - 5}px`;
                element.style.left = `${finalCol * cellWidth}px`;
                element.style.top = `${finalRow * cellHeight}px`;
                
                // 添加内容
                let color = '#f44336'; // 红色 (小)
                let title = '小组件';
                
                if (widgetId === 'system.medium') {
                    color = '#4caf50'; // 绿色 (中)
                    title = '中组件';
                } else if (widgetId === 'system.large') {
                    color = '#ffc107'; // 黄色 (大)
                    title = '大组件';
                } else if (widgetId === 'user.custom') {
                    color = '#2196F3'; // 蓝色 (自定义)
                    title = '自定义组件';
                } else if (widgetId === 'system.model-name') {
                    color = '#9c27b0'; // 紫色 (模型名称)
                    title = '模型名称';
                } else if (widgetId === 'system.model-image') {
                    color = '#ff9800'; // 橙色 (模型图片)
                    title = '模型图片';
                }
                
                element.innerHTML = `
                    <div class="widget-content" style="display: flex; align-items: center; justify-content: center; height: 100%;">
                        <div style="text-align: center; color: ${color}; font-weight: bold;">${width}x${height}</div>
                    </div>
                `;
                
                // 添加到桌面
                desktopGrid.appendChild(element);
                
                // 创建一个简单的组件对象用于保存
                const widget = {
                    getId: () => widgetId,
                    config: config,
                    element: element
                };
                
                // 添加到组件管理器
                widgetManager.widgets.push(widget);
                
                // 保存布局
                widgetManager.saveLayout();
                
                // 在编辑模式下添加拖拽功能
                if (editMode) {
                    element.setAttribute('draggable', 'true');
                    element.classList.add('widget-edit-mode');
                    element.addEventListener('dragstart', handleDragStart);
                    element.addEventListener('dragend', handleDragEnd);
                }
                
                return widget;
            }
            
            // 初始化滑动手势识别
            function initSwipeGesture() {
                let startX = 0;
                let startTime = 0;
                const minDistance = 100; // 最小滑动距离
                const maxTime = 500; // 最大滑动时间 (毫秒)
                
                // 添加测试按钮（仅用于调试）
                const testBtn = document.createElement('button');
                testBtn.textContent = '测试AFC菜单';
                testBtn.style.position = 'fixed';
                testBtn.style.bottom = '10px';
                testBtn.style.right = '10px';
                testBtn.style.zIndex = '9999';
                testBtn.style.padding = '10px';
                testBtn.style.backgroundColor = '#4CAF50';
                testBtn.style.color = 'white';
                testBtn.style.border = 'none';
                testBtn.style.borderRadius = '5px';
                
                testBtn.onclick = function() {
                    console.log('测试按钮点击');
                    showAfcMenu();
                };
                
                document.body.appendChild(testBtn);
                
                // 滑动开始时记录位置和时间
                function handleTouchStart(e) {
                    console.log('触摸开始');
                    // 只有在未处于编辑模式且没有其他菜单显示时才启用滑动
                    const widgetMenu = document.getElementById('widgetMenu');
                    const afcMenu = document.getElementById('afcMenu');
                    
                    if (editMode) {
                        console.log('编辑模式下不响应滑动手势');
                        return;
                    }
                    
                    if ((widgetMenu && widgetMenu.style.right === '0px')) {
                        console.log('组件菜单已打开，不响应滑动手势');
                        return;
                    }
                    
                    if ((afcMenu && afcMenu.style.right === '0px')) {
                        console.log('AFC菜单已打开，不响应滑动手势');
                        return;
                    }
                    
                    startX = e.touches[0].clientX;
                    startTime = Date.now();
                    console.log(`记录起始位置: X=${startX}, 时间=${startTime}`);
                }
                
                // 滑动结束时检查是否符合左滑条件
                function handleTouchEnd(e) {
                    console.log('触摸结束');
                    // 只有在未处于编辑模式且没有其他菜单显示时才启用滑动
                    const widgetMenu = document.getElementById('widgetMenu');
                    const afcMenu = document.getElementById('afcMenu');
                    
                    if (editMode || 
                        (widgetMenu && widgetMenu.style.right === '0px') ||
                        (afcMenu && afcMenu.style.right === '0px')) {
                        console.log('当前状态不响应滑动手势');
                        return;
                    }
                    
                    // 确保这是一次单指滑动
                    if (e.changedTouches.length !== 1) {
                        console.log('非单指滑动，忽略');
                        return;
                    }
                    
                    const endX = e.changedTouches[0].clientX;
                    const endTime = Date.now();
                    const deltaX = endX - startX;
                    const deltaTime = endTime - startTime;
                    
                    console.log(`滑动距离: ${deltaX}px, 时间: ${deltaTime}ms`);
                    console.log(`判断条件: 距离需大于${minDistance}px, 时间需小于${maxTime}ms`);
                    
                    // 如果是从右向左的快速滑动，显示AFC菜单
                    if (deltaX < -minDistance && deltaTime < maxTime) {
                        console.log('检测到左滑手势，显示AFC菜单');
                        showAfcMenu();
                    }
                    
                    // 如果是从左向右的快速滑动，隐藏AFC菜单
                    if (deltaX > minDistance && deltaTime < maxTime) {
                        const menu = document.getElementById('afcMenu');
                        if (menu && menu.style.right === '0px') {
                            console.log('检测到右滑手势，隐藏AFC菜单');
                            hideAfcMenu();
                        }
                    }
                }
                
                // 添加触摸事件监听
                document.addEventListener('touchstart', handleTouchStart, { passive: true });
                document.addEventListener('touchend', handleTouchEnd, { passive: true });
                
                console.log('滑动手势识别已初始化');
            }
            
            // 显示AFC菜单
            function showAfcMenu() {
                console.log('显示AFC菜单');
                
                // 直接获取元素
                let menu = document.getElementById('afcMenu');
                let overlay = document.getElementById('afcMenuOverlay');
                
                if (!menu || !overlay) {
                    console.error('AFC菜单元素不存在');
                    return;
                }
                
                console.log('找到AFC菜单元素，准备显示');
                
                // 显示菜单和遮罩
                overlay.style.display = 'block';
                menu.style.right = '0';
                
                // 添加遮罩点击事件
                overlay.onclick = hideAfcMenu;
                
                console.log('AFC菜单已显示');
            }
            
            // 隐藏AFC菜单
            function hideAfcMenu() {
                console.log('隐藏AFC菜单');
                
                // 直接获取元素
                const menu = document.getElementById('afcMenu');
                const overlay = document.getElementById('afcMenuOverlay');
                
                if (!menu || !overlay) {
                    console.error('AFC菜单元素不存在');
                    return;
                }
                
                menu.style.right = '-300px';
                overlay.style.display = 'none';
                
                console.log('AFC菜单已隐藏');
            }
            
            // 隐藏组件选择菜单
            function hideWidgetMenu() {
                const topWindow = window.top || window;
                
                // 尝试获取顶层窗口的菜单元素
                const menu = topWindow.document.getElementById('widgetMenu');
                const overlay = topWindow.document.getElementById('widgetMenuOverlay');
                
                if (menu && overlay) {
                    // 使用CSS样式隐藏
                    menu.style.right = '-300px';
                    overlay.style.display = 'none';
                }
                
                console.log('隐藏组件选择菜单');
            }
            
            // 触摸拖拽处理 - 移动
            function handleTouchMove(e) {
                // 如果没有正在拖拽的组件，直接返回
                if (!isDragging || !currentDragWidget) {
                    return;
                }
                
                e.preventDefault(); // 阻止滚动
                
                // 获取当前触摸位置
                const touch = e.touches[0];
                const clientX = touch.clientX;
                const clientY = touch.clientY;
                
                // 计算相对于桌面的位置
                const gridRect = desktopGrid.getBoundingClientRect();
                const relX = clientX - gridRect.left;
                const relY = clientY - gridRect.top;
                
                // 考虑拖拽偏移量
                const adjX = relX - dragOffsetX;
                const adjY = relY - dragOffsetY;
                
                // 检查是否在删除区域上方
                const deleteZone = document.getElementById('deleteZone');
                if (deleteZone) {
                    const deleteRect = deleteZone.getBoundingClientRect();
                    if (clientY >= deleteRect.top && clientY <= deleteRect.bottom &&
                        clientX >= deleteRect.left && clientX <= deleteRect.right) {
                        deleteZone.classList.add('drag-over');
                    } else {
                        deleteZone.classList.remove('drag-over');
                    }
                }
                
                // 计算单元格尺寸
                const cellWidth = desktopGrid.clientWidth / 12;
                const cellHeight = desktopGrid.clientHeight / 6;
                
                // 计算网格位置
                const col = Math.floor(adjX / cellWidth);
                const row = Math.floor(adjY / cellHeight);
                
                // 获取组件尺寸
                const width = parseInt(currentDragWidget.dataset.width);
                const height = parseInt(currentDragWidget.dataset.height);
                
                // 确保不超出边界
                const finalCol = Math.max(0, Math.min(col, 12 - width));
                const finalRow = Math.max(0, Math.min(row, 6 - height));
                
                // 更新位置
                currentDragWidget.style.left = `${finalCol * cellWidth}px`;
                currentDragWidget.style.top = `${finalRow * cellHeight}px`;
                
                // 更新数据属性
                currentDragWidget.dataset.col = finalCol;
                currentDragWidget.dataset.row = finalRow;
            }
            
            // 触摸拖拽处理 - 结束
            function handleTouchEnd(e) {
                // 如果没有正在拖拽的组件，直接返回
                if (!isDragging || !currentDragWidget) {
                    return;
                }
                
                // 检查是否在删除区域上方
                const deleteZone = document.getElementById('deleteZone');
                if (deleteZone && deleteZone.classList.contains('drag-over')) {
                    console.log(`删除组件: ${currentDragWidget.id}`);
                    
                    // 从DOM中移除组件
                    currentDragWidget.remove();
                    
                    // 从管理器中移除组件
                    widgetManager.removeWidget(currentDragWidget.id);
                    
                    // 删除结束，移除样式
                    deleteZone.classList.remove('drag-over');
                } else {
                    // 正常放置，更新组件配置
                    const widgetId = currentDragWidget.id;
                    const finalCol = parseInt(currentDragWidget.dataset.col);
                    const finalRow = parseInt(currentDragWidget.dataset.row);
                    
                    console.log(`放置组件: ${widgetId} 在位置 列=${finalCol}, 行=${finalRow}`);
                    
                    // 更新组件配置
                    const widgetObj = widgetManager.widgets.find(w => w.getId() === widgetId);
                    if (widgetObj && widgetObj.config) {
                        widgetObj.config.col = finalCol;
                        widgetObj.config.row = finalRow;
                    }
                }
                
                // 保存布局
                widgetManager.saveLayout();
                
                // 移除拖拽相关样式和状态
                currentDragWidget.classList.remove('dragging');
                isDragging = false;
                currentDragWidget = null;
            }
        });
    </script>
</body>
</html>